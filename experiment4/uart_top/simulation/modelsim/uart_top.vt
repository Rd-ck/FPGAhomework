`timescale 1ps/1ps  //时间精度
`define    Clock 20 //时钟周期

module uart_top_tb;

//========================< 端口 >==========================================
reg                         clk                 ; //时钟，50Mhz
reg                         rst_n               ; //复位，低电平有效
reg                         uart_rx             ;
wire                        uart_tx             ;

//==========================================================================
//==    模块例化
//==========================================================================
uart_top u_uart_top
(
    .clk                    (clk                ),
    .rst_n                  (rst_n              ),
    .uart_rx                (uart_rx            ),
    .uart_tx                (uart_tx            )
);

//==========================================================================
//==    时钟信号和复位信号
//==========================================================================
initial begin
    clk = 1;
    forever
        #(`Clock/2) clk = ~clk;
end

initial begin
    rst_n = 0; #(`Clock*20+1);
    rst_n = 1;
end

//==========================================================================
//==    task任务
//==========================================================================
reg  [7:0]              mem[15:0]           ; //位宽为8，深度为16个数据
integer                 i                   ;
integer                 j                   ;

//读取外部数据
initial $readmemh("./data.txt",mem);

//位赋值
task rx_bit
(
    input [7:0]         data
);
    begin
        for(i=0;i<=9;i=i+1) begin   //10个bit为
            case(i)
                 0: uart_rx = 1'b0;
                 1: uart_rx = data[i-1];
                 2: uart_rx = data[i-1];
                 3: uart_rx = data[i-1];
                 4: uart_rx = data[i-1];
                 5: uart_rx = data[i-1];
                 6: uart_rx = data[i-1];
                 7: uart_rx = data[i-1];
                 8: uart_rx = data[i-1];
                 9: uart_rx = 1'b1;
            endcase
            #1040; //一个完整波特延时：52*20=1040
        end        //考虑到空闲位，也可以设置得1040稍大一些
    end
endtask

//字节赋值
task rx_byte;
    begin
        for(j=0;j<=15;j=j+1) //16个byte数据
            rx_bit(mem[j]);
    end
endtask

//==========================================================================
//==    调用task
//==========================================================================
initial begin
    #(`Clock*20+1);
    rx_byte();
end

initial begin
    #180000;
    $stop;
end

endmodule